#!/usr/bin/env bash

# Git Worktree Manager
# A comprehensive script for managing git worktrees with consistent naming conventions
# Author: Generated for vanducng
# Location: ~/.local/bin/git-worktree-manager

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Get the repository name from the current directory
get_repo_name() {
    if git rev-parse --git-dir > /dev/null 2>&1; then
        basename "$(git rev-parse --show-toplevel)"
    else
        echo ""
    fi
}

# Print usage information
usage() {
    cat << EOF
$(echo -e "${BLUE}Git Worktree Manager${NC}")

USAGE:
    git-worktree-manager <command> [options]

COMMANDS:
    add <branch> [descriptor]    Create a new worktree
    list                         List all worktrees for current repo
    remove <name>                Remove a worktree
    clean                        Remove all worktrees and prune
    switch <name>                Switch to a worktree directory
    help                         Show this help message

OPTIONS for 'add':
    -b <base>    Base branch to create from (default: main or master)
    -t <type>    Type prefix (feature|fix|hotfix|release|dev)
    -n           No branch creation (use existing branch)

EXAMPLES:
    # Create a feature worktree
    git-worktree-manager add feature/auth auth -t feature

    # Create from existing branch
    git-worktree-manager add dev-matt matt -n

    # Create with custom base
    git-worktree-manager add feature/new-ui ui -b develop

    # List all worktrees
    git-worktree-manager list

    # Switch to a worktree
    git-worktree-manager switch auth

    # Remove a worktree
    git-worktree-manager remove donor-verification-auth

NAMING CONVENTION:
    Worktrees are created as: ../\${repo}-\${descriptor}
    Example: ../donor-verification-auth

EOF
}

# Add a new worktree
add_worktree() {
    local branch=""
    local descriptor=""
    local base_branch=""
    local type_prefix=""
    local no_create=false
    local repo_name
    
    repo_name=$(get_repo_name)
    if [[ -z "$repo_name" ]]; then
        echo -e "${RED}Error: Not in a git repository${NC}"
        exit 1
    fi
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -b)
                base_branch="$2"
                shift 2
                ;;
            -t)
                type_prefix="$2"
                shift 2
                ;;
            -n)
                no_create=true
                shift
                ;;
            *)
                if [[ -z "$branch" ]]; then
                    branch="$1"
                elif [[ -z "$descriptor" ]]; then
                    descriptor="$1"
                fi
                shift
                ;;
        esac
    done
    
    # Validate required arguments
    if [[ -z "$branch" ]]; then
        echo -e "${RED}Error: Branch name is required${NC}"
        echo "Usage: git-worktree-manager add <branch> [descriptor] [options]"
        exit 1
    fi
    
    # Generate descriptor from branch if not provided
    if [[ -z "$descriptor" ]]; then
        # Extract meaningful part from branch name
        descriptor=$(echo "$branch" | sed 's/^[^\/]*\///' | sed 's/[\/]/-/g')
    fi
    
    # Add type prefix to descriptor if provided
    if [[ -n "$type_prefix" ]]; then
        descriptor="${type_prefix}-${descriptor}"
    fi
    
    # Determine base branch
    if [[ -z "$base_branch" ]]; then
        if git show-ref --verify --quiet refs/heads/main; then
            base_branch="main"
        elif git show-ref --verify --quiet refs/heads/master; then
            base_branch="master"
        else
            echo -e "${YELLOW}Warning: Could not determine base branch, using current HEAD${NC}"
            base_branch="HEAD"
        fi
    fi
    
    # Construct worktree path
    local worktree_path="../${repo_name}-${descriptor}"
    
    # Check if worktree already exists
    if [[ -d "$worktree_path" ]]; then
        echo -e "${RED}Error: Worktree already exists at $worktree_path${NC}"
        exit 1
    fi
    
    # Create the worktree
    echo -e "${BLUE}Creating worktree...${NC}"
    echo "  Repository: $repo_name"
    echo "  Branch: $branch"
    echo "  Base: $base_branch"
    echo "  Location: $worktree_path"
    
    if $no_create; then
        # Use existing branch
        if ! git show-ref --verify --quiet "refs/heads/$branch"; then
            # Try remote branch
            if git show-ref --verify --quiet "refs/remotes/origin/$branch"; then
                git worktree add "$worktree_path" "origin/$branch"
            else
                echo -e "${RED}Error: Branch '$branch' does not exist${NC}"
                exit 1
            fi
        else
            git worktree add "$worktree_path" "$branch"
        fi
    else
        # Create new branch
        git worktree add -b "$branch" "$worktree_path" "$base_branch"
    fi
    
    echo -e "${GREEN}✓ Worktree created successfully!${NC}"
    echo -e "To navigate to it: ${YELLOW}cd $worktree_path${NC}"
}

# List all worktrees
list_worktrees() {
    local repo_name
    repo_name=$(get_repo_name)
    
    if [[ -z "$repo_name" ]]; then
        echo -e "${RED}Error: Not in a git repository${NC}"
        exit 1
    fi
    
    echo -e "${BLUE}Worktrees for $repo_name:${NC}"
    git worktree list | while IFS= read -r line; do
        path=$(echo "$line" | awk '{print $1}')
        commit=$(echo "$line" | awk '{print $2}')
        branch=$(echo "$line" | sed 's/.*\[//' | sed 's/\]//')
        
        if [[ "$path" == "$(git rev-parse --show-toplevel)" ]]; then
            echo -e "${GREEN}● $path ${NC}(main repository) [$branch]"
        else
            basename_path=$(basename "$path")
            echo -e "  ○ $basename_path -> $path [$branch]"
        fi
    done
    
    # Show disk usage
    echo -e "\n${BLUE}Disk usage:${NC}"
    local total_size=0
    git worktree list | while IFS= read -r line; do
        path=$(echo "$line" | awk '{print $1}')
        if [[ -d "$path" ]]; then
            size=$(du -sh "$path" 2>/dev/null | cut -f1)
            echo "  $size - $(basename "$path")"
        fi
    done
}

# Remove a worktree
remove_worktree() {
    local worktree_name="$1"
    
    if [[ -z "$worktree_name" ]]; then
        echo -e "${RED}Error: Worktree name is required${NC}"
        exit 1
    fi
    
    # Try to find the worktree
    local worktree_path=""
    while IFS= read -r line; do
        path=$(echo "$line" | awk '{print $1}')
        if [[ "$(basename "$path")" == "$worktree_name" ]] || [[ "$path" == "../$worktree_name" ]]; then
            worktree_path="$path"
            break
        fi
    done < <(git worktree list)
    
    if [[ -z "$worktree_path" ]]; then
        echo -e "${RED}Error: Worktree '$worktree_name' not found${NC}"
        echo "Use 'git-worktree-manager list' to see available worktrees"
        exit 1
    fi
    
    # Get the branch name before removing
    local branch_name
    branch_name=$(git worktree list | grep "$worktree_path" | sed 's/.*\[//' | sed 's/\]//')
    
    echo -e "${YELLOW}Removing worktree: $worktree_path [$branch_name]${NC}"
    git worktree remove "$worktree_path"
    
    echo -e "${GREEN}✓ Worktree removed${NC}"
    
    # Ask about branch deletion
    echo -n "Do you want to delete the branch '$branch_name'? (y/N): "
    read -r response
    if [[ "$response" =~ ^[Yy]$ ]]; then
        git branch -D "$branch_name" 2>/dev/null && \
            echo -e "${GREEN}✓ Branch deleted${NC}" || \
            echo -e "${YELLOW}Branch might not exist locally or is not fully merged${NC}"
    fi
}

# Clean all worktrees
clean_worktrees() {
    echo -e "${YELLOW}This will remove ALL worktrees for the current repository.${NC}"
    echo -n "Are you sure? (y/N): "
    read -r response
    
    if [[ ! "$response" =~ ^[Yy]$ ]]; then
        echo "Cancelled"
        exit 0
    fi
    
    local count=0
    while IFS= read -r line; do
        path=$(echo "$line" | awk '{print $1}')
        if [[ "$path" != "$(git rev-parse --show-toplevel)" ]]; then
            echo "Removing: $path"
            git worktree remove "$path" 2>/dev/null && ((count++)) || true
        fi
    done < <(git worktree list)
    
    # Prune any remaining references
    git worktree prune
    
    echo -e "${GREEN}✓ Removed $count worktree(s)${NC}"
}

# Switch to a worktree directory
switch_worktree() {
    local worktree_name="$1"
    
    if [[ -z "$worktree_name" ]]; then
        echo -e "${RED}Error: Worktree name is required${NC}"
        exit 1
    fi
    
    # Find the worktree path
    local worktree_path=""
    while IFS= read -r line; do
        path=$(echo "$line" | awk '{print $1}')
        basename_path=$(basename "$path")
        if [[ "$basename_path" == "$worktree_name" ]] || [[ "$basename_path" == *"$worktree_name" ]]; then
            worktree_path="$path"
            break
        fi
    done < <(git worktree list)
    
    if [[ -z "$worktree_path" ]]; then
        echo -e "${RED}Error: Worktree '$worktree_name' not found${NC}"
        exit 1
    fi
    
    echo -e "${GREEN}Switching to: $worktree_path${NC}"
    echo "Run: cd $worktree_path"
    
    # Note: We can't actually change the directory of the parent shell
    # but we can output the command for the user to run
    echo -e "${YELLOW}Note: Copy and run the cd command above to switch directories${NC}"
}

# Main command dispatcher
main() {
    if [[ $# -eq 0 ]]; then
        usage
        exit 0
    fi
    
    command="$1"
    shift
    
    case "$command" in
        add)
            add_worktree "$@"
            ;;
        list|ls)
            list_worktrees
            ;;
        remove|rm)
            remove_worktree "$@"
            ;;
        clean)
            clean_worktrees
            ;;
        switch|cd)
            switch_worktree "$@"
            ;;
        help|-h|--help)
            usage
            ;;
        *)
            echo -e "${RED}Error: Unknown command '$command'${NC}"
            usage
            exit 1
            ;;
    esac
}

# Run the main function
main "$@"